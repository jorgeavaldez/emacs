#+title: Jorge's Literate Emacs Config
#+startup: overview
#+property: header-args:emacs-lisp :tangle config.el

* Intro
This is a minimal scaffold. Keep it simple, readable, and easy to extend.

* Formatting this =config.org= (manual, no automation yet)
This is the safest literate workflow for formatting Lisp in Org source blocks:
- In an Org src block, run =M-x org-edit-special= (key: =C-c '=).
  - This opens the block in a dedicated Emacs Lisp editing buffer.
- In that edit buffer, format indentation with =M-x indent-region= (key: =C-M-\=).
  - Use =M-x mark-whole-buffer= first if you want to indent the entire block.
- Return to =config.org= with =M-x org-edit-src-exit= (key: =C-c '=).

This keeps formatting focused on code blocks and avoids accidental edits to surrounding Org text.

* ðŸš¨ NEOVIM -> EMACS SURVIVAL CHEATSHEET ðŸš¨
** Key notation
- =C-= means Ctrl
- =M-= means Meta (usually Alt/Option, or press =Esc= then key)

** Leader-first essentials (new default)
- =SPC SPC= :: command palette (=M-x=)
- =SPC f f= :: open file
- =SPC b b= :: switch buffer (Consult)
- =SPC /= :: project grep (ripgrep)
- =SPC s l= :: search in current buffer
- =SPC s i= :: jump to symbol (imenu)
- =SPC s o= :: jump to outline heading
- =SPC ?= :: show available leader bindings

** Get unstuck / quit prompts
- =C-g= :: cancel current command (most important panic key)
- =Esc Esc Esc= :: broad "get me out" escape
- =q= :: quit many special/help buffers

** Discover keybindings (current context)
- =SPC= then pause :: show which-key popup for leader bindings
- =SPC ?= :: force-open top-level leader help
- =C-h m= :: show bindings/docs for current major/minor modes
- =C-h b= :: show all active keybindings right now
- =C-h k= then key :: explain what that key does
- =M-x where-is RET <command>= :: find keybinding for a command

** Movement
- =C-f / C-b= :: right / left
- =C-n / C-p= :: down / up
- =C-a / C-e= :: beginning / end of line
- =M-f / M-b= :: forward / backward word
- =M-<= / =M->= :: top / bottom of buffer
- =C-v / M-v= :: page down / page up
- In Evil normal state: =C-d= and =C-u= already do Vim-style half-page scrolling

** Window/buffer basics
- =C-x o= :: move to other window
- =C-x 2= / =C-x 3= :: split below / split right
- =C-x 0= :: close current window
- =C-x 1= :: keep only current window
- =C-x b= :: switch buffer
- =C-x k= :: kill buffer

** Open files by path
- =C-x C-f= :: open file by path (=find-file=)
- Type absolute path (e.g. =~/.config/emacs/config.org=) or relative path, then =RET=
- Press =TAB= for path completion while typing
- =M-p / M-n= :: previous/next path history in minibuffer
- =C-x C-v= :: visit a different file from current buffer

** Search (Vim =/= style equivalent)
- =C-s= :: incremental forward search (closest built-in to Vim =/=)
- =C-r= :: incremental backward search
- While searching: =C-s= next match, =C-r= previous match
- =RET= :: finish search at current match
- =C-g= :: cancel search and jump back to search start
- =M-e= :: edit search string in minibuffer

** Dired (file manager)
- =C-x d= :: open Dired prompt
- Enter a directory path then =RET= (e.g. =~/.config/emacs= or =.=)
- In Dired:
  - =RET= open file/dir
  - =^= go to parent directory
  - =g= refresh listing

** Reload file/config
- =M-x revert-buffer RET= :: reload current file from disk (after external changes)
- In Dired, =g= refreshes the listing
- Reload this literate config:
  - =M-: (org-babel-load-file (expand-file-name "config.org" user-emacs-directory)) RET=

** Undo / redo
- =C-/= :: undo (also =C-_= or =C-x u=)
- =M-x undo-redo= :: redo (Emacs 28+)

** Org folding (headings)
- =TAB= on a heading :: cycle that subtree folded/children/all
- =S-TAB= :: cycle visibility for whole Org buffer
- =M-x org-cycle= / =M-x org-shifttab= :: command equivalents

** Format this literate config (Org + Lisp blocks)
- Open current src block in dedicated edit buffer:
  - key: =C-c '=, command: =M-x org-edit-special=
- Reindent code in that edit buffer:
  - key: =C-M-\=, command: =M-x indent-region=
  - useful helper: =M-x mark-whole-buffer= before =indent-region=
- Return from src edit buffer to Org:
  - key: =C-c '=, command: =M-x org-edit-src-exit=

** Save / quit Emacs
- =C-x C-s= :: save current buffer
- =C-x s= :: save modified buffers
- =C-x C-c= :: quit Emacs

** Evaluate Lisp quickly
- =C-x b *scratch* RET= :: open scratch buffer
- =C-j= :: eval previous sexp and insert result
- =C-x C-e= :: eval sexp before point (minibuffer result)
- =M-x ielm= :: interactive Emacs Lisp REPL

* Hello world + startup basics
#+begin_src emacs-lisp
;; Keep Customize UI output out of init.el.
(setq custom-file (expand-file-name "custom.el" user-emacs-directory))
(when (file-exists-p custom-file)
  (load custom-file nil 'nomessage))

(setq inhibit-startup-screen t
      initial-scratch-message nil
      ring-bell-function 'ignore)

(add-hook 'emacs-startup-hook
          (lambda ()
            (message "hello world from config.org")))

;; Make yes-or-no questions shorter (y/n instead of typing "yes"/"no")
(fset 'yes-or-no-p 'y-or-n-p)

;; Keep backup files in a separate directory instead of cluttering your folders
(setq backup-directory-alist '(("." . "~/.emacs.d/backups")))
#+end_src

* Phase context (self-contained notes)
This mirrors your migration plan so this file is understandable on its own.

- *Tier 1* (do now): daily muscle memory and core coding loop
  - modal editing, leader keys, key discovery
  - find/search/navigation
- *Tier 2* (next): weekly conveniences (extra workflow helpers, more mappings)
- *Tier 3* (later): optional/rare mappings and polish

In this file, the new sections below implement Tier 1 only.

* Package bootstrap (built-in =package.el= + =use-package=)
What this does:
- enables Emacs package repositories
- ensures =use-package= exists
- makes package declarations consistent and readable

Why:
- this is the simplest "official Emacs" path while learning
- every package below is declared in one place with =use-package=

Note on local files:
- package downloads live in =elpa/= and cache/history files (e.g. =history=, =var/=)
- those are machine-local and are ignored via =.gitignore=

#+begin_src emacs-lisp
(require 'package)

;; Standard package sources.
(setq package-archives
      '(("gnu"    . "https://elpa.gnu.org/packages/")
        ("nongnu" . "https://elpa.nongnu.org/nongnu/")
        ("melpa"  . "https://melpa.org/packages/")))

(package-initialize)

;; Install use-package once, then reuse it everywhere below.
(unless (package-installed-p 'use-package)
  (unless package-archive-contents
    (package-refresh-contents))
  (package-install 'use-package))

(require 'use-package)

;; Default: automatically install missing packages declared with use-package.
(setq use-package-always-ensure t)
#+end_src

* Ensure env vars are set
when we start gui emacs, it only inherits a minimal set of env vars.
unfortunately, this means searching for binaries can fail.
we can fix that using https://github.com/purcell/exec-path-from-shell
#+begin_src emacs-lisp
  (use-package exec-path-from-shell
    :ensure t
    :config
    (when (memq window-system '(mac ns x))
    (exec-path-from-shell-initialize))
  )
#+end_src
* Phase 1 / Step 1: key model (Evil + leader + which-key)
What each package is for:
- =evil=: Vim modal editing in Emacs (normal/insert/visual/etc.)
- =evil-collection=: makes many built-in/package buffers feel Vim-consistent
- =which-key=: shows available key completions after a prefix (great for learning)

Why this setup:
- preserve your Neovim muscle memory
- keep a *small* Tier 1 map first (daily essentials only)
- use Space as leader (Spacemacs-style), plus =SPC SPC= for command palette (=M-x=)

#+begin_src emacs-lisp
  (use-package evil
    :init
    ;; Must be set before Evil loads.
    (setq evil-want-integration t
          evil-want-keybinding nil
          evil-want-C-u-scroll t
          evil-undo-system 'undo-redo)
    :config
    (evil-mode 1))

  (use-package evil-collection
    :after evil
    :config
    (evil-collection-init))

  (use-package which-key
    :defer 0
    :config
    (which-key-mode 1)
    (setq which-key-idle-delay 0.35))

  (defvar jorge/leader-map (make-sparse-keymap)
    "Leader keymap for Evil normal/visual/motion states.")

  (defun jorge/reload-literate-config ()
    "Reload config.org."
    (interactive)
    (org-babel-load-file (expand-file-name "config.org" user-emacs-directory)))

  ;; Non-modal fallback for leader mappings.
  (global-set-key (kbd "C-c SPC") jorge/leader-map)

  (with-eval-after-load 'evil
    (define-key evil-normal-state-map (kbd "SPC") jorge/leader-map)
    (define-key evil-visual-state-map (kbd "SPC") jorge/leader-map)
    (define-key evil-motion-state-map (kbd "SPC") jorge/leader-map))

  ;; we need to define spc to my leader-map in all modes
  ;; so we define our own "global jorge mode" and redefine that shit everywhere
  ;; idk if there's issues w/ just using all my map yet, i def wanted search and keybinds
  ;; general.el will do this for me automagically later
  ;; source: http://blog.lujun9972.win/emacs-document/blog/2019/03/14/evil-guide/
  (defvar jorge-intercept-mode-map (make-sparse-keymap)
    "higher precendence keymap")

  (define-minor-mode jorge-intercept-mode
    "global minor mode for higher precedence bindings"
    :global t)

  ;; do it after evil-colleciton loads its own helpers
  (with-eval-after-load 'evil
    ;; the alternative is to do this for help-model only
    (jorge-intercept-mode 1)
    (dolist (state '(normal visual motion))
      (let ((state-map (evil-get-auxiliary-keymap 
                        jorge-intercept-mode-map state t t)))
        ;; our state map intercepts on the state
        (evil-make-intercept-map state-map state)
        ;; now we bind our leader prefix in this map
        (define-key state-map (kbd "SPC") jorge/leader-map))))

  ;; Spacemacs-style command palette.
  (define-key jorge/leader-map (kbd "SPC") #'execute-extended-command)

  ;; Tier 1 starter mappings (daily essentials only).
  (define-key jorge/leader-map (kbd "f s") #'save-buffer)
  (define-key jorge/leader-map (kbd "f f") #'find-file)
  (define-key jorge/leader-map (kbd "b d") #'kill-current-buffer)


  (defun jorge/save-and-quit ()
    ;; there's no default save and close split
    ;; i don't want this to also delete the buffer, in emacs i'm used to them just living forever anyways
    ;; evil has something built in but then it's evil specific
    (interactive)

    ;; only try to save if this buffer visits a file
    (when (and (buffer-file-name) (buffer-modified-p))
  	(save-buffer))
    (if (one-window-p)
  	  (bury-buffer)
  	(delete-window)))

  (define-key jorge/leader-map (kbd "w v")
  			(lambda ()
  			  (interactive)
  			  (select-window (split-window-right))))

  (define-key jorge/leader-map (kbd "w s")
  			(lambda ()
  			  (interactive)
  			  (select-window (split-window-below))))

  ;; =#'foo= means _the function named foo
  (define-key jorge/leader-map (kbd "w q") #'jorge/save-and-quit)
  (define-key jorge/leader-map (kbd "w o") #'other-window)
  (define-key jorge/leader-map (kbd "w h") #'windmove-left)
  (define-key jorge/leader-map (kbd "w j") #'windmove-down)
  (define-key jorge/leader-map (kbd "w k") #'windmove-up)
  (define-key jorge/leader-map (kbd "w l") #'windmove-right)

  (define-key jorge/leader-map (kbd "c r") #'jorge/reload-literate-config)

  (defun jorge/copy-buffer-full-filename ()
    (interactive)
    (when buffer-file-name
  	(let ((filename (file-truename buffer-file-name)))
  	  (kill-new filename)
  	  (message "Copied %s" filename))))

  (defun jorge/copy-buffer-rel-filename ()
    (interactive)
    (when buffer-file-name
  	(let ((filename
  		  (replace-regexp-in-string (expand-file-name (jorge/default-dir)) "" (file-truename buffer-file-name))))
  	  (kill-new filename)
  	  (message "Copied %s" filename))))

  (define-key jorge/leader-map (kbd "f c") #'jorge/copy-buffer-rel-filename)
  (define-key jorge/leader-map (kbd "f C") #'jorge/copy-buffer-full-filename)

  ;; when we open a help page, it doesn't auto focus unless this is set
  (setq help-window-select t)
  (define-key jorge/leader-map (kbd "h o") #'describe-symbol)
  (define-key jorge/leader-map (kbd "h o") #'describe-symbol)

  (with-eval-after-load 'which-key
    (define-key jorge/leader-map (kbd "?") #'which-key-show-top-level)
    (which-key-add-key-based-replacements
      "SPC b" "buffers"
      "SPC c" "config"
      "SPC f" "files"
      "SPC h" "help"
      "SPC p" "project"
      "SPC s" "search/symbols"
      "SPC w" "windows"
      "SPC SPC" "M-x / command palette"
      "SPC ?" "which-key help"))
#+end_src

* Phase 1 / Step 2: find/search/navigation (Vertico stack + Consult)
Plain-English mental model:
- minibuffer = the prompt area where Emacs asks you for things (files, commands, symbols)
- this stack upgrades that area without changing core Emacs concepts

What each package does:
- =savehist=: remembers past minibuffer inputs (searches, commands, etc.)
- =vertico=: vertical candidate UI in minibuffer
  - this is the display itself. there's ui extensions we can install to configure this.
- =orderless=: fuzzy-ish matching by typing space-separated parts
- =marginalia=: extra annotations in candidate list (type, doc, file info)
- =consult=: the actual high-value commands (search, buffer switch, symbol jump)
  - this provides the list contents and accepts the input to do so

Why this is useful:
- faster finding/searching with less memorization
- keeps everything text-first and keyboard-first
- works cleanly with leader mappings
  
#+begin_src emacs-lisp
  (use-package savehist
    :init
    (savehist-mode 1))

  (use-package vertico
    :init
    (vertico-mode 1)
    :custom
    (vertico-cycle t))

  ;; Configure directory extension.
  (use-package vertico-directory
    :after vertico
    :ensure nil
    ;; More convenient directory navigation commands
    :bind (:map vertico-map
                ("RET" . vertico-directory-enter)
                ("DEL" . vertico-directory-delete-char)
                ("M-DEL" . vertico-directory-delete-word))

    ;; Tidy shadowed file names
    :hook (rfn-eshadow-update-overlay . vertico-directory-tidy))

  (use-package orderless
    :custom
    (completion-styles '(orderless basic))
    (completion-category-defaults nil)
    (completion-category-overrides '((file (styles partial-completion))))
    (orderless-matching-styles '(orderless-flex orderless-literal orderless-regexp)))

  (use-package marginalia
    :after vertico
    :init
    (marginalia-mode 1))

  (defun jorge/default-dir ()
    "Resolve the project root, fallback to current directory)."
    (if-let ((project (project-current nil)))
        (project-root project)
      default-directory))

  (defun jorge/consult-ripgrep-project ()
    "Search text in project root (fallback: current directory)."
    (interactive)
    (consult-ripgrep (jorge/default-dir)))

  (defun jorge/consult-ripgrep-dir ()
    "Search text, scoped to provided directory, defaulting to project root (fallback: current directory)."
    (interactive)
    (consult-ripgrep (read-directory-name "Scope to: " (jorge/default-dir))))

  (defun jorge/consult-fd-dir ()
    "Search for files, scoped to provided directory, defaulting to project root (fallback: current directory)."
    (interactive)
    (consult-fd (read-directory-name "Scope to: " (jorge/default-dir))))

  (use-package consult
    :config
    ;; Better previews for registers and xref results.
    (setq register-preview-delay 0.5
          register-preview-function #'consult-register-format)
    (advice-add #'register-preview :override #'consult-register-window)
    (setq xref-show-xrefs-function #'consult-xref
          xref-show-definitions-function #'consult-xref)

    ;; Start searching sooner while typing
    (setq consult-async-min-input 1
          consult-async-input-debounce 0.05
          consult-async-input-throttle 0.02)

    ;; Faster candidate preview for ripgrep
    (consult-customize
     consult-ripgrep
     :preview-key '(:debounce 0.1 any))

    (consult-customize
     consult-fd
     :preview-key '(:debounce 0.1 any))

    ;; we can type this in the consul buffer, then =h= to see help, or other keys to change the types we search through
    (setq consult-narrow-key "<")
    ;; widen does the opposite
    (setq consult-widen-key ">")

    ;; Leader-first mappings (no extra modifier-key rebinding required).
    (define-key jorge/leader-map (kbd "b b") #'consult-buffer) ;
    (define-key jorge/leader-map (kbd "/") #'jorge/consult-ripgrep-project)
    (define-key jorge/leader-map (kbd "s l") #'consult-line)
    (define-key jorge/leader-map (kbd "s i") #'consult-imenu)
    (define-key jorge/leader-map (kbd "s o") #'consult-outline)
    (define-key jorge/leader-map (kbd "p s") #'jorge/consult-ripgrep-project)
    (define-key jorge/leader-map (kbd "p S") #'jorge/consult-ripgrep-dir)
    (define-key jorge/leader-map (kbd "s s") #'jorge/consult-ripgrep-dir)
    (define-key jorge/leader-map (kbd "p f") #'consult-fd)
    (define-key jorge/leader-map (kbd "p F") #'jorge/consult-fd-dir)
    (define-key jorge/leader-map (kbd "s f") #'jorge/consult-fd-dir))
#+end_src

For now, =embark= is intentionally deferred to keep Phase 1 low-friction.

i just learned embark gives me the ability to export search results into a persistent buffer. def necessary for me, i like to jump between the result and the active search.

** TODO install embark
** TODO set fuzzy search in orderless config
this is called =flex= matching in their parlance. 
mr cheeze bot has the thread on this

* UI defaults
** font
#+begin_src emacs-lisp
  ;; Match Neovim GUI font preference when available.
  (let ((preferred-font "JetBrainsMono Nerd Font Mono"))
    (when (display-graphic-p)
      (if (find-font (font-spec :name preferred-font))
          (set-face-attribute 'default nil :font preferred-font :height 140)
        (message "Font not found: %s (keeping default font)" preferred-font))))
#+end_src
** remove the weird bars and stuff
#+begin_src emacs-lisp
  ;; Keep UI minimal.
  (when (fboundp 'menu-bar-mode) (menu-bar-mode -1))
  (when (fboundp 'tool-bar-mode) (tool-bar-mode -1))
  (when (fboundp 'scroll-bar-mode) (scroll-bar-mode -1))
#+end_src
** macos shit
#+begin_src emacs-lisp
  ;; this stuff removes the whole window frame, but stuff gets misaligned real weird?
  ;; text gets clipped, it's not very nice
  ;; i'm sure with enough nonsense i could fix it
  ;; but tahoe is so bad that the corners get messed up too
  ;; one of these even hides the apple logo button man it's nuts
  ;; (add-to-list 'default-frame-alist '(undecorated . t))
  ;; (setq ns-auto-hide-menu-bar t)
  ;; (set-frame-position nil 0 -24)

  ;; fix the weird bottom gap?
  (setq frame-resize-pixelwise t)
  ;; stackoverflow recommendation, we need to call this more than once to truly maximize
  (dotimes (n 3)
    (toggle-frame-maximized))
#+end_src
** theme - catppuccin
#+begin_src emacs-lisp
  (use-package catppuccin-theme
    :ensure t
    :config
    (setq catppuccin-flavor 'mocha)
    (load-theme 'catppuccin t)
    )
#+end_src

* Editing basics (Neovim-inspired)
#+begin_src emacs-lisp
  ;; Option A: default to tabs, but let major modes override when needed.
  (setq-default indent-tabs-mode t
                tab-width 4)
  (setq standard-indent 4)

  ;; Relative line numbers.
  (setq display-line-numbers-type 'relative)
  (global-display-line-numbers-mode 1)

  ;; Clipboard behavior.
  (setq select-enable-clipboard t
        select-enable-primary t
        save-interprogram-paste-before-kill t)

  ;; Split behavior similar to splitright/splitbelow defaults.
  (setq split-width-threshold 160
        split-height-threshold nil
        window-combination-resize t)

  ;; auto close parens
  (electric-pair-mode 1)
#+end_src

* Transition cleanup
The temporary global bridge bindings were removed now that Evil is active.

Why:
- avoids conflicting behavior between global remaps and Evil state maps
- reduces cognitive load for learning one consistent key model

Current behavior to know:
- in Evil normal state, use Vim-native motions (including =C-d= /=C-u= / =C-o=)
- in minibuffer/Emacs state, default Emacs behavior remains intact

* AI
I integrated my neovim into pi very heavily.
This package should give us a more emacs-native use of everything.

#+begin_src emacs-lisp
  (use-package pi-coding-agent
    :ensure t
    :init (defalias 'pi 'pi-coding-agent)
    :custom
    (pi-coding-agent-copy-raw-markdown t)            ; Keep raw markdown on copy (default: strip hidden markup)
    (pi-coding-agent-input-markdown-highlighting t)  ; GFM syntax highlighting in input buffer
    )

  (define-key jorge/leader-map (kbd "a i") #'pi)
#+end_src

* Markdown
https://jblevins.org/projects/markdown-mode/
i'm getting tired of not being able to read my clanker slop.
#+begin_src emacs-lisp
  (use-package markdown-mode
    :ensure t
    :mode ("README\\.md\\'" . gfm-mode)
    :init (setq markdown-command "multimarkdown")
    :bind (:map markdown-mode-map
  			  ("C-c C-e" . markdown-do)))
#+end_src

* Integrated terminal
the built in terminal is really shitty and doesn't support tuis very well.
eat is an option. vterm is supposed to be the fastest.
for now we're going w/ vterm.
#+begin_src emacs-lisp
  (use-package vterm
    :ensure t)
#+end_src
great!
https://github.com/akermu/emacs-libvterm?tab=readme-ov-file#shell-side-configuration-files
the docs mention that it can integrate w/ my shell.
i'm adding the following to ~/dots/.zshrc
#+begin_src shell :tangle no
  if [["$INSIDE_EMACS" = 'vterm' ]]; then
      # integrate w/ emacs vterm
      function vterm_printf() {
          if [ -n "$TMUX" ] &&
              { [ "${TERM%%-*}" = "tmux" ] ||
                  [ "${TERM%%-*}" = "screen" ]; }; then
              # Tell tmux to pass the escape sequences through
              printf "\ePtmux;\e\e]%s\007\e\\" "$1"
          elif [ "${TERM%%-*}" = "screen" ]; then
              # GNU screen (screen, screen-256color, screen-256color-bce)
              printf "\eP\e]%s\007\e\\" "$1"
          else
              printf "\e]%s\e\\" "$1"
          fi
      }

      function vterm_cmd() {
          local vterm_elisp
          vterm_elisp=""
          while [ $# -gt 0 ]; do
              vterm_elisp="$vterm_elisp""$(printf '"%s" ' "$(printf "%s" "$1" | sed -e 's|\\|\\\\|g' -e 's|"|\\"|g')")"
              shift
          done
          vterm_printf "51;E$vterm_elisp"
      }

      function vterm_prompt_end() {
          vterm_printf "51;A$(whoami)@$(hostname):$(pwd)"
      }
      setopt PROMPT_SUBST
      PROMPT=$PROMPT'%{$(vterm_prompt_end)%}'
  fi
#+end_src
on my mac, this required cmake, and libtool
i installed cmake w/ mise ~mise use -g cmake@latest~
~libtool~ is in homebrew, ~brew install libtool~
** C-c
=C-c C-c= sends escape, so i just basically have to mash it to get it to work properly in pi.
** ESC
=C-[= sends the ESC to vterm. otherwise it exists insert mode.
=C-c C-z= toggles where escape gets sent to.
that's =evil-collection-vterm-toggle-send-escape=
** C-u and evil mode
https://www.reddit.com/r/emacs/comments/9j34bf/comment/e6oecd1/?utm_source=share&utm_medium=web3x&utm_name=web3xcss&utm_term=1&utm_content=share_button
=C-u= is apparently the /universal argument/ that's widely used everywhere.

* shortlist (or, install when i'm bored)
** git-link
https://github.com/sshaw/git-link

* telegram client?!?!
#+begin_src emacs-lisp
    (use-package telega
      :commands (telega)
      :defer t
  	:config
  	(setq telega-server-libs-prefix "/opt/homebrew/Cellar/tdlib/HEAD-6d50906")
(telega-transient-keymaps-mode 1)

  	:bind-keymap
  	("C-c t" . telega-prefix-map)
  )
#+end_src
i had to install tdlib ~brew install tdlib --head~
** forum topic filtering
we can chat in a group forum type, like our openclaw setup, and filter to send messages in a specific topic by runing ~C-c /~ then selecting topic.
that's how i'm chatting to the emacs mistah cheeze and it's working well.
