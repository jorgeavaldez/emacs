#+title: Jorge's Literate Emacs Config
#+startup: overview
#+property: header-args:emacs-lisp :tangle config.el

* Formatting this =config.org= (manual, no automation yet)
This is the safest literate workflow for formatting Lisp in Org source blocks:
- In an Org src block, run =M-x org-edit-special= (key: =C-c '=).
  - This opens the block in a dedicated Emacs Lisp editing buffer.
- In that edit buffer, format indentation with =M-x indent-region= (key: =C-M-\=).
  - Use =M-x mark-whole-buffer= first if you want to indent the entire block.
- Return to =config.org= with =M-x org-edit-src-exit= (key: =C-c '=).

This keeps formatting focused on code blocks and avoids accidental edits to surrounding Org text.

* ðŸš¨ NEOVIM -> EMACS SURVIVAL CHEATSHEET ðŸš¨
** Key notation
- =C-= means Ctrl
- =M-= means Meta (usually Alt/Option, or press =Esc= then key)

** Leader-first essentials (new default)
- =SPC SPC= :: command palette (=M-x=)
- =SPC f o= :: open file
- =SPC f f= :: format file
- =SPC b b= :: switch buffer (Consult)
- =SPC j j= :: JJ log (Majutsu home base)
- =SPC p v= :: open file's directory in Dired (Oil-ish)
- =SPC /= :: project grep (ripgrep)
- =SPC s l= :: search in current buffer
- =SPC s i= :: jump to symbol (imenu)
- =SPC s o= :: jump to outline heading
- =SPC s d= :: diagnostics list (Consult)
- =[d= /=]d= :: previous / next diagnostic
- =SPC ?= :: show available leader bindings

** Get unstuck / quit prompts
- =C-g= :: cancel current command (most important panic key)
- =Esc Esc Esc= :: broad "get me out" escape
- =q= :: quit many special/help buffers

** Discover keybindings (current context)
- =SPC= then pause :: show which-key popup for leader bindings
- =SPC ?= :: force-open top-level leader help
- =C-h m= :: show bindings/docs for current major/minor modes
- =C-h b= :: show all active keybindings right now
- =C-h k= then key :: explain what that key does
- =M-x where-is RET <command>= :: find keybinding for a command

** Movement
- =C-f / C-b= :: right / left
- =C-n / C-p= :: down / up
- =C-a / C-e= :: beginning / end of line
- =M-f / M-b= :: forward / backward word
- =M-<= / =M->= :: top / bottom of buffer
- =C-v / M-v= :: page down / page up
- In Evil normal state: =C-d= and =C-u= already do Vim-style half-page scrolling

** Evil textobjects (tree-sitter)
- =af= / =if= :: around / inside function
- =ac= / =ic= :: around / inside class
- =al= / =il= :: around / inside loop
- =ai= / =ii= :: around / inside conditional
- =a,= / =i,= :: around / inside parameter
- Examples: =daf= delete function, =yic= yank inside class, =ci,= change current parameter
- Note: these work best in buffers with active tree-sitter parsers.

** Window/buffer basics
- =C-x o= :: move to other window
- =C-x 2= / =C-x 3= :: split below / split right
- =C-x 0= :: close current window
- =C-x 1= :: keep only current window
- =C-x b= :: switch buffer
- =C-x k= :: kill buffer
*** Batch buffer killing
i can run =M-x ibuffer= to open a sick buffer gui.
move cursor to the buffers to kill, press =d= to mark the selected line for deletion (this adds a
=D= at the beginning of the line).
once ready, press =x= and poof!
** Open files by path
- =C-x C-f= :: open file by path (=find-file=)
- Type absolute path (e.g. =~/.config/emacs/config.org=) or relative path, then =RET=
- Press =TAB= for path completion while typing
- =M-p / M-n= :: previous/next path history in minibuffer
- =C-x C-v= :: visit a different file from current buffer

** Search (Vim =/= style equivalent)
- =C-s= :: incremental forward search (closest built-in to Vim =/=)
- =C-r= :: incremental backward search
- While searching: =C-s= next match, =C-r= previous match
- =RET= :: finish search at current match
- =C-g= :: cancel search and jump back to search start
- =M-e= :: edit search string in minibuffer

** Dired (file manager)
- =C-x d= :: open Dired prompt
- Enter a directory path then =RET= (e.g. =~/.config/emacs= or =.=)
- In Dired:
  - =RET= open file/dir
  - =^= go to parent directory
  - =g= refresh listing
  - =+= create directory
  - =M-x dired-create-empty-file= create empty file
  - =C-x C-f= create/open file path in this directory

** Wdired (inline rename mode)
- =C-x C-q= :: toggle editable Dired (rename/move existing entries inline)
- Edit names/paths directly in buffer
- =C-c C-c= :: apply changes
- =C-c C-k= :: cancel changes
- NOTE: create new files/dirs in regular Dired (not in Wdired)

** Reload file/config
- =M-x revert-buffer RET= :: reload current file from disk (after external changes)
- In Dired, =g= refreshes the listing
- Reload this literate config:
  - =M-: (org-babel-load-file (expand-file-name "config.org" user-emacs-directory)) RET=

** Undo / redo
- =C-/= :: undo (also =C-_= or =C-x u=)
- =M-x undo-redo= :: redo (Emacs 28+)

** Org folding (headings)
- =TAB= on a heading :: cycle that subtree folded/children/all
- =S-TAB= :: cycle visibility for whole Org buffer
- =M-x org-cycle= / =M-x org-shifttab= :: command equivalents

** Format this literate config (Org + Lisp blocks)
- Open current src block in dedicated edit buffer:
  - key: =C-c '=, command: =M-x org-edit-special=
- Reindent code in that edit buffer:
  - key: =C-M-\=, command: =M-x indent-region=
  - useful helper: =M-x mark-whole-buffer= before =indent-region=
- Return from src edit buffer to Org:
  - key: =C-c '=, command: =M-x org-edit-src-exit=

** Save / quit Emacs
- =C-x C-s= :: save current buffer
- =C-x s= :: save modified buffers
- =C-x C-c= :: quit Emacs

** Evaluate Lisp quickly
- =C-x b *scratch* RET= :: open scratch buffer
- =C-j= :: eval previous sexp and insert result
- =C-x C-e= :: eval sexp before point (minibuffer result)
- =M-x ielm= :: interactive Emacs Lisp REPL

* Hello world + startup basics
#+begin_src emacs-lisp
  ;; Keep Customize UI output out of init.el.
  (setq custom-file (expand-file-name "custom.el" user-emacs-directory))
  (when (file-exists-p custom-file)
    (load custom-file nil 'nomessage))

  (setq inhibit-startup-screen t
        initial-scratch-message nil
        ring-bell-function 'ignore)

  (add-hook 'emacs-startup-hook
            (lambda ()
              (message "hello world from config.org")))

  ;; Make yes-or-no questions shorter (y/n instead of typing "yes"/"no")
  (fset 'yes-or-no-p 'y-or-n-p)

  (global-auto-revert-mode 1)

  ;; Keep backup files in a separate directory instead of cluttering your folders
  (setq backup-directory-alist '(("." . "~/.emacs.d/backups")))
#+end_src

* Package bootstrap (built-in =package.el= + =use-package=)
What this does:
- enables Emacs package repositories
- ensures =use-package= exists
- makes package declarations consistent and readable

Why:
- this is the simplest "official Emacs" path while learning
- every package below is declared in one place with =use-package=

Note on local files:
- package downloads live in =elpa/= and cache/history files (e.g. =history=, =var/=)
- those are machine-local and are ignored via =.gitignore=

#+begin_src emacs-lisp
(require 'package)

;; Standard package sources.
(setq package-archives
      '(("gnu"    . "https://elpa.gnu.org/packages/")
        ("nongnu" . "https://elpa.nongnu.org/nongnu/")
        ("melpa"  . "https://melpa.org/packages/")))

(package-initialize)

;; Install use-package once, then reuse it everywhere below.
(unless (package-installed-p 'use-package)
  (unless package-archive-contents
    (package-refresh-contents))
  (package-install 'use-package))

(require 'use-package)

;; Default: automatically install missing packages declared with use-package.
(setq use-package-always-ensure t)
#+end_src

* Ensure env vars are set
when we start gui emacs, it only inherits a minimal set of env vars.
unfortunately, this means searching for binaries can fail.
we can fix that using https://github.com/purcell/exec-path-from-shell
#+begin_src emacs-lisp
  (use-package exec-path-from-shell
    :ensure t
    :config
    (when (memq window-system '(mac ns x))
    (exec-path-from-shell-initialize))
  )
#+end_src
* Basic bindings and key model (Evil + leader + which-key)
What each package is for:
- =evil=: Vim modal editing in Emacs (normal/insert/visual/etc.)
- =evil-collection=: makes many built-in/package buffers feel Vim-consistent
- =which-key=: shows available key completions after a prefix (great for learning)

Why this setup:
- preserve your Neovim muscle memory
- keep a *small* Tier 1 map first (daily essentials only)
- use Space as leader (Spacemacs-style), plus =SPC SPC= for command palette (=M-x=)

#+begin_src emacs-lisp
  (use-package evil
    :init
    ;; Must be set before Evil loads.
    (setq evil-want-integration t
          evil-want-keybinding nil
          evil-want-C-u-scroll t
          evil-undo-system 'undo-redo
  		evil-visual-update-x-selection-p nil
  		evil-kill-on-visual-paste nil)
    :config
    (evil-mode 1))

  (use-package evil-collection
    :after evil
    :config
    (evil-collection-init))

  (use-package evil-org
    :ensure t
    :after org
    :hook (org-mode . (lambda () evil-org-mode))
    :config
    (require 'evil-org-agenda)
    (evil-org-agenda-set-keys)
    ;; this removes the C-i binding, which is native emacs tab
    (setq evil-want-C-i-jump nil))

  (use-package which-key
    :defer 0
    :config
    (which-key-mode 1)
    (setq which-key-idle-delay 0.35))

  (defvar jorge/leader-map (make-sparse-keymap)
    "Leader keymap for Evil normal/visual/motion states.")

  (defun jorge/reload-literate-config ()
    "Reload config.org."
    (interactive)
    (org-babel-load-file (expand-file-name "config.org" user-emacs-directory)))

  ;; Non-modal fallback for leader mappings.
  (global-set-key (kbd "C-c SPC") jorge/leader-map)

  (with-eval-after-load 'evil
    (define-key evil-normal-state-map (kbd "SPC") jorge/leader-map)
    (define-key evil-visual-state-map (kbd "SPC") jorge/leader-map)
    (define-key evil-motion-state-map (kbd "SPC") jorge/leader-map))

  ;; we need to define spc to my leader-map in all modes
  ;; so we define our own "global jorge mode" and redefine that shit everywhere
  ;; idk if there's issues w/ just using all my map yet, i def wanted search and keybinds
  ;; general.el will do this for me automagically later
  ;; source: http://blog.lujun9972.win/emacs-document/blog/2019/03/14/evil-guide/
  (defvar jorge-intercept-mode-map (make-sparse-keymap)
    "higher precendence keymap")

  (define-minor-mode jorge-intercept-mode
    "global minor mode for higher precedence bindings"
    :global t)

  ;; do it after evil-colleciton loads its own helpers
  (with-eval-after-load 'evil
    ;; the alternative is to do this for help-model only
    (jorge-intercept-mode 1)
    (dolist (state '(normal visual motion))
      (let ((state-map (evil-get-auxiliary-keymap 
                        jorge-intercept-mode-map state t t)))
        ;; our state map intercepts on the state
        (evil-make-intercept-map state-map state)
        ;; now we bind our leader prefix in this map
        (define-key state-map (kbd "SPC") jorge/leader-map))))

  ;; Spacemacs-style command palette.
  (define-key jorge/leader-map (kbd "SPC") #'execute-extended-command)

  ;; Tier 1 starter mappings (daily essentials only).
  (define-key jorge/leader-map (kbd "f s") #'save-buffer)
  (define-key jorge/leader-map (kbd "f o") #'find-file)
  (define-key jorge/leader-map (kbd "b d") #'kill-current-buffer)


  (defun jorge/save-and-quit ()
    ;; there's no default save and close split
    ;; i don't want this to also delete the buffer, in emacs i'm used to them just living forever anyways
    ;; evil has something built in but then it's evil specific
    (interactive)

    ;; only try to save if this buffer visits a file
    (when (and (buffer-file-name) (buffer-modified-p))
  	(save-buffer))
    (if (one-window-p)
  	  (bury-buffer)
  	(delete-window)))

  (define-key jorge/leader-map (kbd "w v")
  			(lambda ()
  			  (interactive)
  			  (select-window (split-window-right))))

  (define-key jorge/leader-map (kbd "w s")
  			(lambda ()
  			  (interactive)
  			  (select-window (split-window-below))))

  ;; =#'foo= means _the function named foo
  (define-key jorge/leader-map (kbd "w q") #'jorge/save-and-quit)
  (define-key jorge/leader-map (kbd "w o") #'other-window)
  (define-key jorge/leader-map (kbd "w h") #'windmove-left)
  (define-key jorge/leader-map (kbd "w j") #'windmove-down)
  (define-key jorge/leader-map (kbd "w k") #'windmove-up)
  (define-key jorge/leader-map (kbd "w l") #'windmove-right)

  (define-key jorge/leader-map (kbd "c r") #'jorge/reload-literate-config)

  (defun jorge/copy-buffer-full-filename ()
    (interactive)
    (when buffer-file-name
  	(let ((filename (file-truename buffer-file-name)))
  	  (kill-new filename)
  	  (message "Copied %s" filename))))

  (defun jorge/copy-buffer-rel-filename ()
    (interactive)
    (when buffer-file-name
  	(let ((filename
  		  (replace-regexp-in-string (expand-file-name (jorge/default-dir)) "" (file-truename buffer-file-name))))
  	  (kill-new filename)
  	  (message "Copied %s" filename))))

  (define-key jorge/leader-map (kbd "f c") #'jorge/copy-buffer-rel-filename)
  (define-key jorge/leader-map (kbd "f C") #'jorge/copy-buffer-full-filename)

  ;; when we open a help page, it doesn't auto focus unless this is set
  (setq help-window-select t)
  (define-key jorge/leader-map (kbd "h o") #'describe-symbol)
  (define-key jorge/leader-map (kbd "h o") #'describe-symbol)

  (with-eval-after-load 'which-key
    (define-key jorge/leader-map (kbd "?") #'which-key-show-top-level)
    (which-key-add-key-based-replacements
      "SPC b" "buffers"
      "SPC c" "config"
      "SPC f" "files"
      "SPC h" "help"
      "SPC p" "project"
      "SPC p v" "open file dir (dired)"
      "SPC s" "search/symbols"
      "SPC w" "windows"
      "SPC SPC" "M-x / command palette"
      "SPC ?" "which-key help"))
#+end_src

* find/search/navigation (Vertico stack + Consult)
Plain-English mental model:
- minibuffer = the prompt area where Emacs asks you for things (files, commands, symbols)
- this stack upgrades that area without changing core Emacs concepts

What each package does:
- =savehist=: remembers past minibuffer inputs (searches, commands, etc.)
- =vertico=: vertical candidate UI in minibuffer
  - this is the display itself. there's ui extensions we can install to configure this.
- =orderless=: fuzzy-ish matching by typing space-separated parts
- =marginalia=: extra annotations in candidate list (type, doc, file info)
- =consult=: the actual high-value commands (search, buffer switch, symbol jump)
  - this provides the list contents and accepts the input to do so

Why this is useful:
- faster finding/searching with less memorization
- keeps everything text-first and keyboard-first
- works cleanly with leader mappings
  
#+begin_src emacs-lisp
  (use-package savehist
    :init
    (savehist-mode 1))

  (use-package vertico
    :init
    (vertico-mode 1)
    :custom
    (vertico-cycle t))

  ;; Configure directory extension.
  (use-package vertico-directory
    :after vertico
    :ensure nil
    ;; More convenient directory navigation commands
    :bind (:map vertico-map
                ("RET" . vertico-directory-enter)
                ("DEL" . vertico-directory-delete-char)
                ("M-DEL" . vertico-directory-delete-word))

    ;; Tidy shadowed file names
    :hook (rfn-eshadow-update-overlay . vertico-directory-tidy))

  (use-package orderless
    :custom
    (completion-styles '(orderless basic))
    (completion-category-defaults nil)
    (completion-category-overrides '((file (styles partial-completion))))
    (orderless-matching-styles '(orderless-flex orderless-literal orderless-regexp)))

  (use-package marginalia
    :after vertico
    :init
    (marginalia-mode 1))

  (defun jorge/default-dir ()
    "Resolve the project root, fallback to current directory)."
    (if-let ((project (project-current nil)))
        (project-root project)
      default-directory))

  (defun jorge/consult-ripgrep-project ()
    "Search text in project root (fallback: current directory)."
    (interactive)
    (consult-ripgrep (jorge/default-dir)))

  (defun jorge/consult-ripgrep-dir ()
    "Search text, scoped to provided directory, defaulting to project root (fallback: current directory)."
    (interactive)
    (consult-ripgrep (read-directory-name "Scope to: " (jorge/default-dir))))

  (defun jorge/consult-fd-dir ()
    "Search for files, scoped to provided directory, defaulting to project root (fallback: current directory)."
    (interactive)
    (consult-fd (read-directory-name "Scope to: " (jorge/default-dir))))

  (defun jorge/dired-here ()
    "Open Dired in current file's directory.
If current buffer has no file, fallback to `default-directory'."
    (interactive)
    (let ((dir (if buffer-file-name
                   (file-name-directory (file-truename buffer-file-name))
                 default-directory)))
      (dired dir)))

  (use-package consult
    :config
    ;; Better previews for registers and xref results.
    (setq register-preview-delay 0.5
          register-preview-function #'consult-register-format)
    (advice-add #'register-preview :override #'consult-register-window)
    (setq xref-show-xrefs-function #'consult-xref
          xref-show-definitions-function #'consult-xref)

    ;; Start searching sooner while typing
    (setq consult-async-min-input 1
          consult-async-input-debounce 0.05
          consult-async-input-throttle 0.02
  		consult-fd-args "fd --type f --hidden --no-require-git --exclude .git --exclude .jj")

    ;; Faster candidate preview for ripgrep
    (consult-customize
     consult-ripgrep
     :preview-key '(:debounce 0.1 any))

    (consult-customize
     consult-fd
     :preview-key '(:debounce 0.1 any))

    ;; we can type this in the consul buffer, then =h= to see help, or other keys to change the types we search through
    (setq consult-narrow-key "<")
    ;; widen does the opposite
    (setq consult-widen-key ">")

    ;; Leader-first mappings (no extra modifier-key rebinding required).
    (define-key jorge/leader-map (kbd "b b") #'consult-buffer) ;
    (define-key jorge/leader-map (kbd "/") #'jorge/consult-ripgrep-project)
    (define-key jorge/leader-map (kbd "s l") #'consult-line)
    (define-key jorge/leader-map (kbd "s i") #'consult-imenu)
    (define-key jorge/leader-map (kbd "s o") #'consult-outline)
    (define-key jorge/leader-map (kbd "p s") #'jorge/consult-ripgrep-project)
    (define-key jorge/leader-map (kbd "p S") #'jorge/consult-ripgrep-dir)
    (define-key jorge/leader-map (kbd "s s") #'jorge/consult-ripgrep-dir)
    (define-key jorge/leader-map (kbd "p f") #'consult-fd)
    (define-key jorge/leader-map (kbd "p F") #'jorge/consult-fd-dir)
    (define-key jorge/leader-map (kbd "p v") #'jorge/dired-here)
    (define-key jorge/leader-map (kbd "s f") #'jorge/consult-fd-dir))
#+end_src

For now, =embark= is intentionally deferred to keep Phase 1 low-friction.

i just learned embark gives me the ability to export search results into a persistent buffer. def necessary for me, i like to jump between the result and the active search.

** TODO install embark
** TODO set fuzzy search in orderless config
this is called =flex= matching in their parlance. 
mr cheeze bot has the thread on this

* LSP + completion + formatting + linting
#+begin_src emacs-lisp
  ;; Tree-sitter mode remap/fallback/install flow.
  (use-package treesit-auto
    :if (fboundp 'treesit-available-p)
    :demand t
    :custom
    ;; Prompt before cloning/building grammar.
    (treesit-auto-install 'prompt)
    :config
    ;; Match language surface area from the current Neovim config.
    ;; Note: terraform/hcl isn't in treesit-auto's built-in recipe list.
    (setq treesit-auto-langs
          '(python
            javascript typescript tsx json
            html css
            bash
            lua
            go gomod gowork
            rust
            zig
            yaml sql markdown toml dockerfile))

    ;; Ensure these extensions map to a real mode instead of fundamental-mode.
    (treesit-auto-add-to-auto-mode-alist
     '(python
       javascript typescript tsx json
       html css
       bash
       lua
       go gomod gowork
       rust
       zig
       yaml sql markdown toml dockerfile))

    (global-treesit-auto-mode 1))

  ;; In-buffer completion UI.
  (use-package corfu
    :init
    (global-corfu-mode 1)
    :custom
    (corfu-auto t)
    (corfu-auto-delay 0.12)
    (corfu-auto-prefix 1)
    (corfu-preview-current nil)
    (corfu-cycle t)
    :bind
    (:map corfu-map
          ("TAB" . corfu-next)
          ([tab] . corfu-next)
          ("S-TAB" . corfu-previous)
          ([backtab] . corfu-previous)))

  ;; Extra completion sources (CAPF extensions).
  (use-package cape
    :after corfu
    :init
    (add-to-list 'completion-at-point-functions #'cape-file t)
    (add-to-list 'completion-at-point-functions #'cape-dabbrev t)
    :config
    (with-eval-after-load 'eglot
      ;; Keep Eglot completion candidates fresh as buffer changes.
      (advice-add 'eglot-completion-at-point :around #'cape-wrap-buster)))

  (defun jorge/eglot-ensure ()
    "Start Eglot for current buffer when appropriate."
    (unless (or (minibufferp)
                (file-remote-p default-directory))
      (eglot-ensure)))

  (use-package eglot
    :ensure nil
    :demand t
    :hook ((python-mode . jorge/eglot-ensure)
           (python-ts-mode . jorge/eglot-ensure)
           (js-mode . jorge/eglot-ensure)
           (js-ts-mode . jorge/eglot-ensure)
           (javascript-mode . jorge/eglot-ensure)
           (typescript-mode . jorge/eglot-ensure)
           (typescript-ts-mode . jorge/eglot-ensure)
           (tsx-ts-mode . jorge/eglot-ensure))
    :config
    (let ((py-server (eglot-alternatives
                      '(("basedpyright-langserver" "--stdio")
                        ("pyright-langserver" "--stdio"))))
          (ts-server (eglot-alternatives
                      '(("typescript-language-server" "--stdio")
                        ("bunx" "--bun" "typescript-language-server" "--stdio")
                        ("npx" "typescript-language-server" "--stdio")))))
      ;; Use setf/alist-get so reloading config doesn't duplicate entries.
      (setf (alist-get '(python-mode python-ts-mode)
                       eglot-server-programs nil nil #'equal)
            py-server
            (alist-get '(js-mode js-ts-mode javascript-mode typescript-mode typescript-ts-mode tsx-ts-mode)
                       eglot-server-programs nil nil #'equal)
            ts-server))

    ;; Keep import organization with Ruff/Biome tooling pipeline.
    (setq-default eglot-workspace-configuration
                  '((:pyright . (:disableOrganizeImports t))
                    (:basedpyright . (:disableOrganizeImports t))))

    (require 'consult-flymake nil t)

    (defun jorge/diagnostics-list ()
      "Open diagnostics list, preferring consult-flymake."
      (interactive)
      (cond
       ((fboundp 'consult-flymake)
        (consult-flymake))
       ((fboundp 'flymake-show-buffer-diagnostics)
        (flymake-show-buffer-diagnostics))
       (t
        (user-error "No diagnostics list command available"))))

    ;; LSP core parity bindings.
    (define-key jorge/leader-map (kbd "k") #'eldoc-doc-buffer)
    (define-key jorge/leader-map (kbd "d") #'display-local-help)
    (define-key jorge/leader-map (kbd "c a") #'eglot-code-actions)
    (define-key jorge/leader-map (kbd "r") #'eglot-rename)
    (define-key jorge/leader-map (kbd "s d") #'jorge/diagnostics-list)
    (define-key jorge/leader-map (kbd "p d") #'flymake-show-project-diagnostics)

    (with-eval-after-load 'evil
      (define-key evil-normal-state-map (kbd "gd") #'xref-find-definitions)
      (define-key evil-normal-state-map (kbd "gr") #'xref-find-references)
      (define-key evil-normal-state-map (kbd "gi") #'eglot-find-implementation)))

  ;; Ruff diagnostics for python buffers (alongside pyright/basedpyright typing).
  (use-package flymake-ruff
    :hook ((python-mode . flymake-ruff-load)
           (python-ts-mode . flymake-ruff-load)))

  ;; Formatter orchestration (manual only; no format-on-save).
  (use-package apheleia
    :config
    ;; Prefer Apheleia builtins where available; add only missing ones.
    ;; Match Neovim conform config for tools Apheleia doesn't ship.
    (setf (alist-get 'yamlfmt apheleia-formatters)
          '("yamlfmt" "-")
          (alist-get 'sqlfmt apheleia-formatters)
          '("sqlfmt" "-")
          (alist-get 'djlint apheleia-formatters)
          '("djlint" "--reformat" "-"))

    ;; Biome-first for JS/TS, prettier-markdown for Markdown, Ruff for Python,
    ;; and parity with Neovim formatter mappings for Lua/YAML/SQL/shell/templates.
    (setf (alist-get 'js-mode apheleia-mode-alist) 'biome
          (alist-get 'js-ts-mode apheleia-mode-alist) 'biome
          (alist-get 'javascript-mode apheleia-mode-alist) 'biome
          (alist-get 'js-jsx-mode apheleia-mode-alist) 'biome
          (alist-get 'js2-jsx-mode apheleia-mode-alist) 'biome
          (alist-get 'rjsx-mode apheleia-mode-alist) 'biome
          (alist-get 'typescript-mode apheleia-mode-alist) 'biome
          (alist-get 'typescript-ts-mode apheleia-mode-alist) 'biome
          (alist-get 'tsx-ts-mode apheleia-mode-alist) 'biome
          (alist-get 'json-mode apheleia-mode-alist) 'biome
          (alist-get 'json-ts-mode apheleia-mode-alist) 'biome
          (alist-get 'jsonc-mode apheleia-mode-alist) 'biome
          (alist-get 'markdown-mode apheleia-mode-alist) 'prettier-markdown
          (alist-get 'lua-mode apheleia-mode-alist) 'stylua
          (alist-get 'lua-ts-mode apheleia-mode-alist) 'stylua
          (alist-get 'yaml-mode apheleia-mode-alist) 'yamlfmt
          (alist-get 'yaml-ts-mode apheleia-mode-alist) 'yamlfmt
          (alist-get 'sql-mode apheleia-mode-alist) 'sqlfmt
          (alist-get 'sh-mode apheleia-mode-alist) 'shfmt
          (alist-get 'bash-ts-mode apheleia-mode-alist) 'shfmt
          (alist-get 'zsh-mode apheleia-mode-alist) 'shfmt
          (alist-get 'django-mode apheleia-mode-alist) 'djlint
          (alist-get 'jinja2-mode apheleia-mode-alist) 'djlint
          (alist-get "\\.jinja\\.html\\'" apheleia-mode-alist) 'djlint
          (alist-get "\\.djhtml\\'" apheleia-mode-alist) 'djlint
          (alist-get 'python-mode apheleia-mode-alist) 'ruff
          (alist-get 'python-ts-mode apheleia-mode-alist) 'ruff)

    (defun jorge/format-file ()
      "Format current file manually.
Prefer Apheleia formatter mappings, fallback to LSP format."
      (interactive)
      (let ((formatters (apheleia--get-formatters)))
        (cond
         (formatters
          (apheleia-format-buffer formatters))
         ((bound-and-true-p eglot-managed-mode)
          (eglot-format-buffer))
         (t
          (user-error "No formatter configured for %s" major-mode)))))

    (define-key jorge/leader-map (kbd "f f") #'jorge/format-file))

  (with-eval-after-load 'which-key
    (which-key-add-key-based-replacements
      "SPC f f" "format file"
      "SPC k" "hover/help"
      "SPC d" "diagnostic at point"
      "SPC c a" "code action"
      "SPC r" "rename symbol"
      "SPC s d" "diagnostics list"
      "SPC p d" "project diagnostics"
      "gd" "go to definition"
      "gr" "go to references"
      "gi" "go to implementation"))

  ;; Tree-sitter powered evil textobjects.
  ;; Package: https://github.com/meain/evil-textobj-tree-sitter
  (use-package evil-textobj-tree-sitter
    :after evil
    :config
    ;; Match Neovim-style textobjects where available.
    ;; - af/if => function
    ;; - ac/ic => class
    ;; - al/il => loop
    ;; - ai/ii => conditional
    ;; - a, / i, => parameter
    (define-key evil-outer-text-objects-map "f"
                (evil-textobj-tree-sitter-get-textobj "function.outer"))
    (define-key evil-inner-text-objects-map "f"
                (evil-textobj-tree-sitter-get-textobj "function.inner"))

    (define-key evil-outer-text-objects-map "c"
                (evil-textobj-tree-sitter-get-textobj "class.outer"))
    (define-key evil-inner-text-objects-map "c"
                (evil-textobj-tree-sitter-get-textobj "class.inner"))

    (define-key evil-outer-text-objects-map "l"
                (evil-textobj-tree-sitter-get-textobj "loop.outer"))
    (define-key evil-inner-text-objects-map "l"
                (evil-textobj-tree-sitter-get-textobj "loop.inner"))

    (define-key evil-outer-text-objects-map "i"
                (evil-textobj-tree-sitter-get-textobj "conditional.outer"))
    (define-key evil-inner-text-objects-map "i"
                (evil-textobj-tree-sitter-get-textobj "conditional.inner"))

    (define-key evil-outer-text-objects-map ","
                (evil-textobj-tree-sitter-get-textobj "parameter.outer"))
    (define-key evil-inner-text-objects-map ","
                (evil-textobj-tree-sitter-get-textobj "parameter.inner")))

  ;; Neovim-parity tree-sitter motions: ]f/[f, ]c/[c, ]l, ]s/[s, ]i/[i, ]z
  ;; (start/end variants for function/class use uppercase like ]F/[F, ]C/[C).
  (defconst jorge/treesit-motion-regex-alist
    '((function . "\\`\\(?:function\\(?:_\\(?:definition\\|declaration\\|expression\\|item\\|signature\\)\\)?\\|method\\(?:_\\(?:definition\\|declaration\\)\\)?\\|arrow_function\\|generator_function_declaration\\|lexical_declaration\\|decorated_definition\\|function_item\\)\\'")
      (class . "\\`\\(?:class\\(?:_\\(?:definition\\|declaration\\|body\\)\\)?\\|impl_item\\|trait_item\\)\\'")
      (loop . "\\`\\(?:for\\(?:_\\(?:statement\\|in_statement\\|of_statement\\)\\)?\\|while_statement\\|do_statement\\|loop_expression\\|loop_statement\\|repeat_statement\\)\\'")
      (scope . "\\`\\(?:statement_block\\|block\\|class_body\\|program\\|module\\|namespace_body\\)\\'")
      (conditional . "\\`\\(?:if_statement\\|if_expression\\|switch_statement\\|match_expression\\|conditional_expression\\|case_clause\\)\\'")
      ;; fold-ish fallback when dedicated fold captures aren't available
      (fold . "\\`\\(?:statement_block\\|block\\|class_body\\|program\\|module\\|namespace_body\\)\\'"))
    "Node-type regexes used for tree-sitter movement commands.")

  (defun jorge/treesit--motion-predicate (kind)
    "Resolve movement predicate for KIND."
    (cond
     ;; Prefer mode-provided defun navigation when available.
     ((and (eq kind 'function) (treesit-thing-defined-p 'defun))
      'defun)
     (t
      (or (alist-get kind jorge/treesit-motion-regex-alist)
          (user-error "Unknown treesit motion kind: %s" kind)))))

  (defun jorge/treesit-goto (kind backward goto-start)
    "Move point using tree-sitter by KIND.
If BACKWARD is non-nil, search backward. If GOTO-START is non-nil,
move to node start; otherwise move to node end."
    (unless (and (fboundp 'treesit-node-at)
                 (treesit-parser-list))
      (user-error "No tree-sitter parser active in this buffer"))
    (let* ((start-node (or (treesit-node-at (point))
                           (treesit-buffer-root-node)))
           (predicate (jorge/treesit--motion-predicate kind))
           (node (treesit-search-forward-goto
                  start-node predicate goto-start backward t)))
      (unless node
        (user-error "No %s found" kind))))

  ;; Function motions
  (defun jorge/treesit-next-function-start () (interactive) (jorge/treesit-goto 'function nil t))
  (defun jorge/treesit-next-function-end ()   (interactive) (jorge/treesit-goto 'function nil nil))
  (defun jorge/treesit-prev-function-start () (interactive) (jorge/treesit-goto 'function t t))
  (defun jorge/treesit-prev-function-end ()   (interactive) (jorge/treesit-goto 'function t nil))

  ;; Class motions
  (defun jorge/treesit-next-class-start () (interactive) (jorge/treesit-goto 'class nil t))
  (defun jorge/treesit-next-class-end ()   (interactive) (jorge/treesit-goto 'class nil nil))
  (defun jorge/treesit-prev-class-start () (interactive) (jorge/treesit-goto 'class t t))
  (defun jorge/treesit-prev-class-end ()   (interactive) (jorge/treesit-goto 'class t nil))

  ;; Other tree-sitter motions
  (defun jorge/treesit-next-loop-start ()        (interactive) (jorge/treesit-goto 'loop nil t))
  (defun jorge/treesit-next-scope-start ()       (interactive) (jorge/treesit-goto 'scope nil t))
  (defun jorge/treesit-prev-scope-start ()       (interactive) (jorge/treesit-goto 'scope t t))
  (defun jorge/treesit-next-conditional-start () (interactive) (jorge/treesit-goto 'conditional nil t))
  (defun jorge/treesit-prev-conditional-start () (interactive) (jorge/treesit-goto 'conditional t t))
  (defun jorge/treesit-next-fold-start ()        (interactive) (jorge/treesit-goto 'fold nil t))

  (with-eval-after-load 'evil
    ;; diagnostics (already matching Neovim muscle memory)
    (define-key evil-normal-state-map (kbd "]d") #'flymake-goto-next-error)
    (define-key evil-normal-state-map (kbd "[d") #'flymake-goto-prev-error)

    ;; tree-sitter motion parity
    (define-key evil-normal-state-map (kbd "]f") #'jorge/treesit-next-function-start)
    (define-key evil-normal-state-map (kbd "]F") #'jorge/treesit-next-function-end)
    (define-key evil-normal-state-map (kbd "[f") #'jorge/treesit-prev-function-start)
    (define-key evil-normal-state-map (kbd "[F") #'jorge/treesit-prev-function-end)

    (define-key evil-normal-state-map (kbd "]c") #'jorge/treesit-next-class-start)
    (define-key evil-normal-state-map (kbd "]C") #'jorge/treesit-next-class-end)
    (define-key evil-normal-state-map (kbd "[c") #'jorge/treesit-prev-class-start)
    (define-key evil-normal-state-map (kbd "[C") #'jorge/treesit-prev-class-end)

    (define-key evil-normal-state-map (kbd "]l") #'jorge/treesit-next-loop-start)
    (define-key evil-normal-state-map (kbd "]s") #'jorge/treesit-next-scope-start)
    (define-key evil-normal-state-map (kbd "[s") #'jorge/treesit-prev-scope-start)
    (define-key evil-normal-state-map (kbd "]i") #'jorge/treesit-next-conditional-start)
    (define-key evil-normal-state-map (kbd "[i") #'jorge/treesit-prev-conditional-start)
    (define-key evil-normal-state-map (kbd "]z") #'jorge/treesit-next-fold-start))

  (with-eval-after-load 'which-key
    (which-key-add-key-based-replacements
      "]f" "next function start"
      "]F" "next function end"
      "[f" "prev function start"
      "[F" "prev function end"
      "]c" "next class start"
      "]C" "next class end"
      "[c" "prev class start"
      "[C" "prev class end"
      "]l" "next loop"
      "]s" "next scope"
      "[s" "prev scope"
      "]i" "next conditional"
      "[i" "prev conditional"
      "]z" "next fold"
      "]d" "next diagnostic"
      "[d" "prev diagnostic"))
#+end_src

* VCS / JJ (Majutsu, minimal bootstrap)
For now, keep JJ intentionally small:
- one entry point: =SPC j j=
- open Majutsu log view (home base)
- learn the Majutsu UI first before adding extra leader bindings

#+begin_src emacs-lisp
  (use-package majutsu
    :vc (:url "https://github.com/0WD0/majutsu")
    :commands (majutsu majutsu-log)
    :init
    ;; Minimal JJ muscle-memory starter: home base log view.
    (define-key jorge/leader-map (kbd "j j") #'majutsu-log))

  (with-eval-after-load 'which-key
    (which-key-add-key-based-replacements
      "SPC j" "jujutsu"
      "SPC j j" "jj log (majutsu)"))
#+end_src

* UI defaults
** font
#+begin_src emacs-lisp
  ;; Match Neovim GUI font preference when available.
  (let ((preferred-font "JetBrainsMono Nerd Font Mono"))
    (when (display-graphic-p)
      (if (find-font (font-spec :name preferred-font))
          (set-face-attribute 'default nil :font preferred-font :height 140)
        (message "Font not found: %s (keeping default font)" preferred-font))))
#+end_src
** remove the weird bars and stuff
#+begin_src emacs-lisp
  ;; Keep UI minimal.
  (when (fboundp 'menu-bar-mode) (menu-bar-mode -1))
  (when (fboundp 'tool-bar-mode) (tool-bar-mode -1))
  (when (fboundp 'scroll-bar-mode) (scroll-bar-mode -1))
#+end_src
** macos shit
#+begin_src emacs-lisp
  ;; this stuff removes the whole window frame, but stuff gets misaligned real weird?
  ;; text gets clipped, it's not very nice
  ;; i'm sure with enough nonsense i could fix it
  ;; but tahoe is so bad that the corners get messed up too
  ;; one of these even hides the apple logo button man it's nuts
  ;; (add-to-list 'default-frame-alist '(undecorated . t))
  ;; (setq ns-auto-hide-menu-bar t)
  ;; (set-frame-position nil 0 -24)

  ;; fix the weird bottom gap?
  (setq frame-resize-pixelwise t)
  ;; stackoverflow recommendation, we need to call this more than once to truly maximize
  (dotimes (n 3)
    (toggle-frame-maximized))
#+end_src
** theme - catppuccin
#+begin_src emacs-lisp
  (use-package catppuccin-theme
    :ensure t
    :config
    (setq catppuccin-flavor 'mocha)
    (load-theme 'catppuccin t)
    )
#+end_src

** highlight current line in code editing type modes
#+begin_src emacs-lisp
  (setq global-hl-line-sticky-flag t) ;; keep highlight visible in other windows

  (global-hl-line-mode 1)

  ;; disable for any non-code ones
  (defun jorge/hl-line-for-editing-buffers ()
    (if (or (minibufferp)
            (derived-mode-p 'special-mode 'comint-mode 'eshell-mode 'term-mode 'vterm-mode))
        (hl-line-mode -1)
      (hl-line-mode 1)))

  (add-hook 'after-change-major-mode-hook #'jorge/hl-line-for-editing-buffers)
#+end_src
* Editing basics (Neovim-inspired)
#+begin_src emacs-lisp
  ;; default to tabs, but let major modes override when needed.
  (setq-default indent-tabs-mode t
                tab-width 4)
  (setq standard-indent 4)

  ;; Relative line numbers.
  (setq display-line-numbers-type 'relative)
  (global-display-line-numbers-mode 1)

  ;; Clipboard behavior.
  (setq select-enable-clipboard t
        select-enable-primary t
        save-interprogram-paste-before-kill t)

  ;; Split behavior similar to splitright/splitbelow defaults.
  (setq split-width-threshold 160
        split-height-threshold nil
        window-combination-resize t)

  ;; auto close parens
  (electric-pair-mode 1)
#+end_src

* AI
I integrated my neovim into pi very heavily.
This package should give us a more emacs-native use of everything.

#+begin_src emacs-lisp
  (use-package pi-coding-agent
    :ensure t
    :init (defalias 'pi 'pi-coding-agent)
    :custom
    (pi-coding-agent-copy-raw-markdown t)            ; Keep raw markdown on copy (default: strip hidden markup)
    (pi-coding-agent-input-markdown-highlighting t)  ; GFM syntax highlighting in input buffer
    )

  (define-key jorge/leader-map (kbd "a i") #'pi)
#+end_src

* Markdown
https://jblevins.org/projects/markdown-mode/
i'm getting tired of not being able to read my clanker slop.
#+begin_src emacs-lisp
  (use-package markdown-mode
    :ensure t
    :mode ("README\\.md\\'" . gfm-mode)
    :init (setq markdown-command "multimarkdown")
    :bind (:map markdown-mode-map
  			  ("C-c C-e" . markdown-do)))
#+end_src

* Integrated terminal
the built in terminal is really shitty and doesn't support tuis very well.
eat is an option. vterm is supposed to be the fastest.
for now we're going w/ vterm.
#+begin_src emacs-lisp
  (use-package vterm
    :ensure t)
#+end_src
great!
https://github.com/akermu/emacs-libvterm?tab=readme-ov-file#shell-side-configuration-files
the docs mention that it can integrate w/ my shell.
i'm adding the following to ~/dots/.zshrc
#+begin_src shell :tangle no
  if [["$INSIDE_EMACS" = 'vterm' ]]; then
      # integrate w/ emacs vterm
      function vterm_printf() {
          if [ -n "$TMUX" ] &&
              { [ "${TERM%%-*}" = "tmux" ] ||
                  [ "${TERM%%-*}" = "screen" ]; }; then
              # Tell tmux to pass the escape sequences through
              printf "\ePtmux;\e\e]%s\007\e\\" "$1"
          elif [ "${TERM%%-*}" = "screen" ]; then
              # GNU screen (screen, screen-256color, screen-256color-bce)
              printf "\eP\e]%s\007\e\\" "$1"
          else
              printf "\e]%s\e\\" "$1"
          fi
      }

      function vterm_cmd() {
          local vterm_elisp
          vterm_elisp=""
          while [ $# -gt 0 ]; do
              vterm_elisp="$vterm_elisp""$(printf '"%s" ' "$(printf "%s" "$1" | sed -e 's|\\|\\\\|g' -e 's|"|\\"|g')")"
              shift
          done
          vterm_printf "51;E$vterm_elisp"
      }

      function vterm_prompt_end() {
          vterm_printf "51;A$(whoami)@$(hostname):$(pwd)"
      }
      setopt PROMPT_SUBST
      PROMPT=$PROMPT'%{$(vterm_prompt_end)%}'
  fi
#+end_src
on my mac, this required cmake, and libtool
i installed cmake w/ mise ~mise use -g cmake@latest~
~libtool~ is in homebrew, ~brew install libtool~
** C-c
=C-c C-c= sends escape, so i just basically have to mash it to get it to work properly in pi.
** ESC
=C-[= sends the ESC to vterm. otherwise it exists insert mode.
=C-c C-z= toggles where escape gets sent to.
that's =evil-collection-vterm-toggle-send-escape=
** C-u and evil mode
https://www.reddit.com/r/emacs/comments/9j34bf/comment/e6oecd1/?utm_source=share&utm_medium=web3x&utm_name=web3xcss&utm_term=1&utm_content=share_button
=C-u= is apparently the /universal argument/ that's widely used everywhere.

* shortlist (or, install when i'm bored)
** git-link
https://github.com/sshaw/git-link

* telegram client?!?!
#+begin_src emacs-lisp
    (use-package telega
      :commands (telega)
      :defer t
  	:config
  	(setq telega-server-libs-prefix "/opt/homebrew/Cellar/tdlib/HEAD-6d50906")
(telega-transient-keymaps-mode 1)

  	:bind-keymap
  	("C-c t" . telega-prefix-map)
  )
#+end_src
i had to install tdlib ~brew install tdlib --head~
** forum topic filtering
we can chat in a group forum type, like our openclaw setup, and filter to send messages in a specific topic by runing ~C-c /~ then selecting topic.
that's how i'm chatting to the emacs mistah cheeze and it's working well.

* next up!
** get jj working
*** prompt
read through /Users/jorge/obsidian/delvaze/garden/migration-to-emacs.md very carefully
this is my migration to emacs plan.
i'm currently using neovim but i'm switching over piece by piece and i'm trying to learn everything from first principles.
right now, i want to start integration w/ jj for vcs control.
~/.config/nvim/lua/jorge/jj.lua contains my current neovim vcs stuff.
i'm looking at potentially using majutsu since i prefer jj. i'm already a bit used to magit so it's familiar.
review the plan, then give me an overview of how you're going to update my config.
be sure to keep it straightforward for now. let me know of possible improvements.
review my keybindings from neovim for vcs stuff and offer analogous ones. for the most part, i require `SPC gs` at a minimum.
if you have any clarifying questions, comments, concerns, STOP and let me address them for you before you continue.
** ergonomic pi
pi mode sucks so far because opening a bunch gets unwieldy w/ having to pop up both the input + the view buffers at the same time.
i want to open it in a new tab, and have tab nav bindings
~SPC t~ menu.
~SPC tn~ next.
~SPC tp~ prev.
~SPC tl~ search menu.
when i run ~SPC ai~, i want it to by default run ~C-u M-x pi~, with a default name (some number, counting the curr session),
allowing me to rename if i desire.
when pressing enter, i want it to open in a new tab on its own.
if i swap to a pi buffer, i want it to also bring along it's buddy the chat view, or the input view, depending on which one i bring.
it should be the one specific to that session.
if i can do that then that's better than weird tabs stuff. i prefer single buffer nav.
https://github.com/nex3/perspective-el
this perspective thing might give me exactly what i want too.
